#define _CRT_SECURE_NO_WARNINGS 1 
#include<stdio.h>
//算数操作符 + - * / %
//int main()
//{
//	int a = 3 / 2;//1
//	//两端为整数执行整数除法
//	//int a = 9.0 % 2;//报错
//	int a = 9 % 2;
//	//结果为 0 - 2 模数：2 - 1
//
//	return 0;
//}
//移位操作符
//科普：
//整数的二进制表示有三种形式，原反补
//正整数的原反补是相同的
//负整数的原反补是需要计算的

//int main()
//{
//	int a = 5;//101
//	//binary:0000 0000 0000 0000 0000 0000 0000 0101
//	//第一位为符号位：0 - 正 / 1 - 负
//	int b = -5;
//	//反码 = 符号位不变，其他位置按位取反
//	//补码 = 反码 + 1
// 补码得到原码的方式：补码按位取反 + 1 ->原码
//	//原：1000 0000 0000 0000 0000 0000 0000 0101
//	//反：1111 1111 1111 1111 1111 1111 1111 1010
//	//补：1111 1111 1111 1111 1111 1111 1111 1011
//	//整数在内存中存储的是补码的二进制
//	//打印出的是原码
//	 
//}
//移位操作符移动的均为补码
//int main()
//{
//	int a = 5;
//	int b = a << 1;//操作的二进制位
//	//0000 0000 0000 0000 0000 0000 0000 0101 -> 左移：左边丢弃，右边补0
//	//0 [000 0000 0000 0000 0000 0000 0000 101] 0
//	//由于是二进制位移动，所以左移也有 * 2的说法
//	printf("b = %d\n", b);
//}
//
//int main()
//{
//	int a = 5;
//	int b = a >> 1;
//	//0000 0000 0000 0000 0000 0000 0000 0101
//	//0000 0000 0000 0000 0000 0000 0000 0010
// printf("b = %d\n", b);//3
//	int a1 = -5;
//	int b1 = a1 >> 1;//当前编译器，在右移时采用算数右移
//	//1111 1111 1111 1111 1111 1111 1111 1011
//	//1 [111 1111 1111 1111 1111 1111 1111 1101] 1 - 右移
// printf("b1 = %d\n", b1);
//}
//右移操作符
//算数右移：右边丢弃，左边补原符号位
//逻辑右移：右边丢弃，左边补0
//取决于编译器
//& - 按位与
//| - 按位或
//^ - 按位异或
//int main()
//{
//	int a = 3;
//	int b = -5;
//	int c = a & b;
//	printf("c = %d", c);//3
//	//0000 0000 0000 0000 0000 0000 0000 0011 - 补码
//	//1000 0000 0000 0000 0000 0000 0000 0101 - 原码
//	//1111 1111 1111 1111 1111 1111 1111 1010 - 反码
//	//1111 1111 1111 1111 1111 1111 1111 1011 - 补码
//
//	//按位与：对应二进制位只要有一个0，就为0，同时为1，则为1
//	//0000 0000 0000 0000 0000 0000 0000 0011 结果：- 3
//}
//int main()
//{
//	int a = 3;
//	int b = -5;
//	int c = a | b;
//	printf("c = %d", c);//-5
//	//按位或：对应二进制位只要有一个1，就为1，同时为0，则为0
//	//0000 0000 0000 0000 0000 0000 0000 0011 - 补码
//	//1111 1111 1111 1111 1111 1111 1111 1011 - 按位或
//	//1000 0000 0000 0000 0000 0000 0000 0100 - 取反
//	//1000 0000 0000 0000 0000 0000 0000 0101 - + 1 - 结果：-5
//}
//int main()
//{
//	int a = 3;
//	int b = -5;
//	int c = a ^ b;
//	printf("c = %d", c);//-8
//	//0000 0000 0000 0000 0000 0000 0000 0011 - 补码
//	//1111 1111 1111 1111 1111 1111 1111 1011 - 补码
//	//按位异或：对应二进制位，相同为0，相异为1
//	//1111 1111 1111 1111 1111 1111 1111 1000 - 按位异或
//	//1000 0000 0000 0000 0000 0000 0000 0111 - 取反
//	//1000 0000 0000 0000 0000 0000 0000 1000 - + 1 - 结果：-8
//}

//a^a = 0
//0^a = a
//找出现一次的数字1 2 3 4 5 1 2 3 4
//异或，因为相同异或为0，0异或数字得到数字本身
//0000
//0101
//0101
//int main()
//{
//	int arr[] = { 1,2,3,4,5,1,2,3,4 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int i = 0;
//	int num = 0;
//	for (i = 0; i < sz; i++)
//	{
//		num ^= arr[i];
//	}
//	printf("%d\n", num);
//}
//不允许创建临时变量,实现两个变量交换
//plan1:两数相加会溢出
//int main()
//{
//	int a = 3;
//	int b = 5;
//	printf("交换前：a = %d b = %d\n", a, b);
//	a = a + b;//和：8
//	b = a - b;//把a的值放到b，和 - 从前的b：5
//	a = a - b;//把b的值放到a，和 - 现在的b：3
//	printf("交换后：a = %d b = %d\n", a, b);
//}
//plan2:
int main()
{
	int a = 3;
	int b = 5;
	printf("交换前：a = %d b = %d\n", a, b);
	a = a ^ b;//1
	b = a ^ b;//2
	a = a ^ b;//3
	//1：
	//a：011 b：101
	//a ^ b = 110
	//a = 110 = 6
	//------------
	//2：
	//a：110 b：101
	//a ^ b = 011
	//b = 011 = 3
	//------------
	//3：
	//a：110 b：011
	//a ^ b = 101
	//a = 101 = 5
	printf("交换后：a = %d b = %d\n", a, b);
}