#define _CRT_SECURE_NO_WARNINGS 1 

#include <stdio.h>

//int main()
//{
//	char arr[10] = "3%";
//	printf(arr);//3
//	printf("\n%s\n", arr);//3%
//	return 0;
//}
// 为什么？
// printf第一个参数是格式字符串
// %有特殊含义
// 第一个printf只有一个参数
// 第一次打印参数只有一个arr，就认为第一个认为是格式化字符串
// 第二个认为由于有两个参数第一个参数%s，格式化字符串已经有了
// 所以认为arr，是你要打印的内容，认为这是一个格式化的数据
// 而不是格式化字符串


// 这个例子可能更加清晰些
// 我们把printf第一个参数设定为%s
// 第二个参数设置为字符串

//int main()
//{
//	char arr1[] = "%s";
//	char arr2[] = "abcde";
//	printf(arr1, arr2);
//	return 0;
//}

// arr1被当做格式化字符串直接替换到printf中
// printf有一个特性会把第一个参数认为是告诉它格式是什么
// 然后再通过格式对格式化数据进行打印

// 如果当printf只有一个参数时，
// 当参数中含有%时，会把其解释为格式化字符串
// 特殊处理的过程和打印的结果不得而知

// 如果参数不含%，则会认为打印的是常量字符串，直接进行打印
// 就像printf("hello world");一样
// 常量字符串表达式的值其实为h的地址
// 那么可以把这个地址放入指针中，通过指针打印出字符串

// 因为printf("hello")是把h的地址传给了printf，
// hello这个表达式的值就是h的地址，这样打印没问题
// 所以我把其他部分省略，我也是把地址传给printf
// 写成printf(arr);的形式也可以
// 这就相当于
// 会把参数当做地址，打印出字符串

// printf("hello") --> char* p = "hello"; printf(p);

int main()
{
	int a = 1;
	int b = 2;

	printf("%d %d", a);//1 随机值
	printf("%d", a, b);//1 不打印
}

// printf打印的数据根据格式字符串的个数来决定
// printf格式化数据很多，但是格式化字符串只有1个时，打印一个数据
// printf打印元素的个数取决于格式字符串的多少
// 格式字符串和格式数据需要对应