#define _CRT_SECURE_NO_WARNINGS 1 
#include<stdio.h>
//int main()
//{
//	//char 虽然是字符类型，但是字符类型存储的时候，
//	//存储的字符的ascii码值，ascii值是整数
//	unsigned char;//无符号
//	signed char;//有符号
//	//有无符号有什么影响?
//	//有正负的数据可以存放在有符号的变量中
//	//只有整数的数据可以存放在无符号的变量中
//
//	//有符号数据，最高位是符号位，其他位是数据位
//	//无符号数据，最高位也是数据位
//
//	//short,int,long都等价于signed
//	//char不确定，C语言标准没有规定char是否有符号，取决于编译器
//
//	return 0;
//}

//构造类型(自定义类型)
//数组类型
//int arr[10];//arr的类型是：int [10]
//数组只要个数和元素类型发生变化，类型都会发生变化
//结构体类型 strtct
//枚举类型 enum
//联合类型 union

//空类型
//void test(void)
//{
//
//}
//int main()
//{
//
//}

//整数可以写出三种二进制表示形式
//原码：直接将数值按照正负的形式翻译成二进制就可以
//反码：原码的符号位不变，其他位依次按位取反就可以得到了
//补码：反码 + 1得到补码
//正整数的原码、反码、补码相同
//负数的原码、反码、补码是要计算的
int main()
{
	int a = 10;//整形值
	//原码：0000 0000 0000 0000 0000 0000 0000 1010
	//反码：0000 0000 0000 0000 0000 0000 0000 1010
	//补码：0000 0000 0000 0000 0000 0000 0000 1010
	//0x0000000a

	int b = -10;//整形值
	//原码：1000 0000 0000 0000 0000 0000 0000 1010
	//反码：1111 1111 1111 1111 1111 1111 1111 0101
	//补码：1111 1111 1111 1111 1111 1111 1111 0110
	//观察整数在内存中是否存的补码
	//       F    F    F    F    F    F    F    6
	//0xfffffff6
}
//2进制  0 ~ 1
//8进制  0 ~ 7
//10进制 0 ~ 9
//16进制 0 ~ 9 a ~ f 组成 0 ~ 15
//16进制可以更加直观的描述二进制位

//为什么数据在内存中存的是补码？
//int main()
//{
//	1 - 1;
//	//CPU 中只有加法器
//	//1 + ( -1 )
//	//假设用原码来计算加法
//	//0000 0000 0000 0000 0000 0000 0000 0001
//	//1000 0000 0000 0000 0000 0000 0000 0001
//	//相加，发现使用原码计算是错误的
//	//1000 0000 0000 0000 0000 0000 0000 0010 - -2结果错误
//
//	//使用补码的二进制计算
//	//0000 0000 0000 0000 0000 0000 0000 0001 -  1补码
//	//1111 1111 1111 1111 1111 1111 1111 1111 - -1补码
//	//和1的补码进行相加
//	//1000 0000 0000 0000 0000 0000 0000 00000
//	//一直进1，然后多一位，所以要把后32个比特位的数据保留
//	//其他的丢弃
//	//得到的结果就是0
//	return 0;
//}

//char - signed char：0 ~ 127 && -1 ~ -128
//一个字节
//八个比特位

//0000 0000
//0000 0001
//...
//0111 1111 - 127
//1000 0000 - 直接解析为 - 128
//1000 0001 - -127
//...
//1111 1110 - -2
//1111 1111 - -1

//1111 1111为补码
//1000 0000
//1000 0001

//那么对于unsigned char呢？
//无符号位那么
//以上情况取值范围就是0 ~ 255

//int main()
//{
//	unsigned int ch = -10;
//	//把一个负数放入，当然可以放入，但是结果会不同
//	printf("%u", ch);//4294967286
//	//为什么？
//	//- 10
//	//1000 0000 0000 0000 0000 0000 0000 1010
//	//1111 1111 1111 1111 1111 1111 1111 0101
//	//1111 1111 1111 1111 1111 1111 1111 1111 - 补码，存在ch中的就是这个值
//	//%u打印无符号数，不是无符号数我也认为是无符号数
//	printf("%d\n", ch);//是打印有符号数，意思是你要我打印的一定是有符号数，不是有符号数，我也认为是有符号数
//	//那么在内存中存的就是有符号数的补码，打印出来的就是有符号数的原码
//	//所以还是会打印有符号数，即-10
//	return 0;
//}

//signed short;//-32768 ~ -32767
//unsigned short;//0 ~ 65535

//大小端讲解
//int main()
//{
//	int a = 0x11223344;
//	//发现数据倒着存储
//	//为什么？
//
//	return 0;
//}
//大小端字节序存储：为了让存储方式变得更简单，就有了大小端，乱序的话还原逻辑复杂

//前提准备
//众所周知，123的高权值位为1，低权值位为3
//所以对于地址来说也是这样这里的高权值位就为11，低权值位就为44
//大端字节序存储：把一个数据低位字节处的数据存放在高地址处，把高位字节处的数据放在低地址处
//小端字节序存储：把一个数据低位字节处的数据存放在低地址处，把高位字节处的数据放在高地址处。