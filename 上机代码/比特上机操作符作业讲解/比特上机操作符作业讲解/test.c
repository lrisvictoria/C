#define _CRT_SECURE_NO_WARNINGS 1
//获取一个整数的二进制序列
#include<stdio.h>
//一个数按位与1，得到的结果为0或1
//只要将这个数右移31次，就可以得到所有位的二进制位
//判断结果是否为真得到结果
//int main()
//{
//  int n = 0;
//  scanf("%d, &n);
//	int count = 0;
//	int i = 0;
//	for (i = 0; i < 32; i++)
//	{
//		if ((n >> i) & 1)
//			count++;
//	}
//	printf("%d\n", count);
//	return 0;
//}
//将1左移31次，让数的每一位和1按位与，若得到的结果为非0
//则说明该位为1
//int main()
//{
//  int n = 0;
//  scanf("%d, &n);
//	int count = 0;
//	int i = 0;
//	for (i = 0; i < 32; i++)
//	{
//		if (n & (1 << i))
//			count++;
//	}
//	printf("%d\n", count);
//	return 0;
//}
//15 % 2 = 7 ... 1
//其实拿到的就是二进制位：1111的最后一位
//15 / 2 = 7
//7 % 2 = 3 ...1
//其实拿到的就是倒数第二位
//7 / 2
//3 % 2 = 1 ... 1
//其实拿到的就是第二位
//3 / 2
//1 % 2 = 0 ... 1
//拿到第一位
//1 / 2
//处理负数数据时可以封装函数，函数参数设定为unsigned int
//
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	int count = 0;
//	while (n)
//	{
//		if (n % 2 == 1)
//			count++;
//		n /= 2;
//	}
//	printf("%d\n", count);
//	return 0;
//}
//采用改变n的值，右移31位
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	int i = 0;
//	int count = 0;
//	for (i = 0; i < 32; i++)
//	{
//		if ((n & 1) == 1)
//			count++;
//		n >>= 1;
//	}
//}
//还能再优化吗？
//先看一个算法：
//n = 11;
//n = n & (n - 1)
//1011 - n
//1010 - n - 1
//1010 - n
//最后一位的1不见了
//1001 - n - 1
//1000 - n
//倒数第二位1不见了
//0111 - n - 1
//0000 - n
//二进制位里面1都没有了
//其实也很容易理解按位与只要有一个0则为0
//两个都为1则为1，所以当你将你的数字 - 1
//得到的结果按位与，最后一位肯定会消失一位
//相当于减去后的数你问前面借了一位，而借的话就相当于丢失一位
//原先为1的位就会变成0，因此就可以把这一位的1消除掉
//而且只会动后面的位，因为借位借的就是后面的位，和前面没关系
//那一位就被你-1的结果给置为0了！
//也就是说，该循环每进行一次都会少一个1
//执行几次就有几个1
//int main()
//{
//	int count = 0;
//	int n = 0;
//	scanf("%d", &n);
//	while (n)
//	{
//		n &= n - 1;
//		count++;
//	}
//	printf("%d\n", count);
//	return 0;
//}

//拓展一下
//n&(n-1)
//算这个数是否为2的n次方，
//16
//00010000
//00001111
//只要n&(n-1) == 0
//就是
//因为2的n次方在二进制中就只有1个1
//所以可以n-1按位与的结果就一定为0，因为借1，后面的位都改变，全为0
//当然也可以通过统计2进制中1个个数，来判断
//也可以通过别的方法，自行探究~
