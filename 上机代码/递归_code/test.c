#define _CRT_SECURE_NO_WARNINGS 1 
#include<stdio.h>
//编写函数不允许创建临时变量，求字符串的长度
//int main()
//{
//	char arr[] = "abc";
//	int len = strlen(arr);
//	printf("%d\n", len);
//	return 0;
//}


//求斐波那契数
//int fib(int n)
//{
//	int a = 1;
//	int b = 1;
//	int c = 0;
//	while (n > 2)
//	{
//		c = a + b;
//		a = b;
//		b = c;
//		n--;
//	}
//	return c;
//}
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	int ret = fib(n);
//	printf("%d\n", ret);
//}

//void func(int* p)
//{
//	*p++;//错误
//}
//int main()
//{
//	int n = 12;
//	func(&n);
//	printf("%d\n", n);
//	return 0;
//}
//++优先级较高，先和p结合，然后*再和p结合
//但是++是先使用后++，所以这个式子相当于先*p得到0，在对p++
//实际上并没有对*p起到改变作用，所以并不能改变变量n的值
//对p的地址进行++，也就是指针指向了n变量后的空间
//但是n的值并没有改变，它仅仅是改变指向，如果想要改变n的值，
//需要通过*访问到地址所指向的空间，对空间中的内容进行修改
//仅仅这种方法并不会对内容进行修改，所以打印结果依然是0。
//正确方法为：(*p)++

//如果在一个代码中创建了静态变量
//当递归每次调用函数时，使用的都是一份空间，和普通变量不同
//每次调用都需要开辟空间
//虽然对阻止栈溢出有些作用，但是不明显
//void swap(int* px, int* py)
//{
//	*px;//*px的修改才能影响外面的a
//	*py;
//}
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int* pa = &a;
//	int* pb = &b;
//	swap(&a, &b);
//}
//当实参为地址时，形参也是独立开辟的一块空间
//因为他们的地址相同，说形参是实参的一份临时拷贝有点讲不通
//但是确实是这样

//int g_val = 200;
//void a()
//{
//	g_val = 2022;
//}
//void b()
//{
//	printf("%d\n", g_val);
//}
//int main()
//{
//	a();
//	b();
//	//不同次序调用函数改变全局变量时
//	//a的修改会影响到b的结果
//	//它们之间依赖性比较强
//	//所以不建议这么使用
//}

//高内聚低耦合
//低耦合 - 设计函数每个模块的关联度不是很高
//高内聚 - 函数模块尽量独立
//其中重要的一点就是少使用全局变量，因为全局变量会把模块之间关联起来


//int main()
//{
//	int arr[2] = { 0 };
//	//数组传参只能用数组名传递
//	test(arr);
//	//test(arr[2]);//错误
//	return 0;
//}

//用全局变量改变局部变量x,y
//共享思维
//int g_x = 0;
//int g_y = 0;
//void test()
//{
//	int a  = 10;
//	int b = 20;
//	g_x = a;
//	g_y = b;
//}
//int main()
//{
//
//	test();
//	int x = g_x;
//	int y = g_y;
//	printf("%d %d\n", x, y);
//	return 0;
//}

//在两个.c文件中，可以通过extern进行函数声明，在.c文件之间调用函数

//函数设计的时候可以没有返回值，但是你设计的函数有返回值就一定要返回
//例如，你对于函数返回的返回仅仅规定了一部分，那么不满足返回条件的
//会返回什么值？
//
int test()
{
	int a = 10;
	scanf("%d", &a);
	if (0)
		return 1;
}
int main()
{
	int ret = test();
	printf("%d\n", ret);
	return 0;
}
//当编译时，会出现如下警告：不是所有的控件路径都返回值
//就是并没有规定如果不满足条件会返回什么，没有涵盖所有范围
//至于返回什么值，这是不可知的，全看编译器自己的发挥
//一定要给编译器完整的返回条件和返回值的规定