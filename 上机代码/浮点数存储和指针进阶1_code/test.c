#define _CRT_SECURE_NO_WARNINGS 1 
//浮点数在内存中无法精确保存
//因为可能是无限循环小数
//这就是浮点数精度丢失的原因

//#include<stdio.h>
//#include<string.h>
//int main()
//{
//	int a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
	////printf("%d", strlen(a));//以字节为单位。计算一个short计算两次
	////char类型占一个字节，修改数组元素修改一个字节，也就是两个十六进制位
	////short类型占两个字节，修改数组元素修改两个字节，也就是四个十六进制位
	////strlen以字节为单位计算长度
	////当char第255次，将低地址处的第一个字节改为0时，short和int的第一个字节也会被改为0
	////由于是小端存储，所以取出来时这一位会是0x......00的样子，所以在strlen计算长度时，遇到这一位停止
	////这时char计算结果为255，short由于改动的字节时它的两倍，short计算的大小为510，int则是1020
//}

//存有效数字m是，由于M的取值范围为1<=m<2，一定会有一个1，所以在存储时
//将小数点后面的数字存入,这样子就可以保存24位，1位一位，小数点后23位
//将小数点后的数据存入，不够的补0

//对于指数位E对于32位则是将其加上127，存入8个比特位中
//对于64位则是1023

//练习一下
//int main()
//{
//	float f = 5.5f;
//	//s = 0
//	//5.5写成二进制
//	//101.1
//	//M = 1.001
//	//E = 2
//	//0 10000001 00100000000000000000000
//	//内存中
//	//04 0b 00 00
//	return 0;
//}

// 这时，浮点数的指数等于1-127即为真实值
//有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数
//这样做是为了表示+-0,以及接近于0的很小的数字
//相当于0.xxxxx*2^-126

//将E为全1时，如果有效数字全为0，表示x无穷大，这时有效数字不再加上1
//0/1 1111 1111 000 0000 0000 0000 000 0000
//有效数字全0表示正负无穷大，尾数有数字就是表示具体数据

//指针数组
//#include<stdio.h>
//int main()
//{
//	char* arr[5] ={"1","2","3","4","5"};//存放指针的数组，元素都是常量字符串
//	int i = 0;
//	for (i = 0; i < 5; i++)
//	{
//		printf("%s\n", arr[i]);
//	}
//	return 0;
//}
//模拟二维数组
//#include<stdio.h>
//int main()
//{
//	int arr1[5] = { 1,2,3,4,5 };
//	int arr2[5] = { 2,3,4,5,6 };
//	int arr3[5] = { 3,4,5,6,7 };
//	int* arr[] = { arr1,arr2,arr3 };
//	int i = 0;
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d ", *(*(arr + i) + j));
//		}
//		printf("\n");
//	}
//	return 0;
//}

//数组指针，存放的是数组的地址
//int main()
//{
//	int arr[10] = { 1,2,3,4,5 };
//	int(*pa)[10] = &arr;//取出的是数组的地址存放到pa中，pa是数组指针
//	//类型int(*)[10]
//	//就像int arr[10]一样，把arr去掉int [10]就是数组的类型
//	//去掉名字就是类型
//}

//数组指针，+1跳过整个数组的大小，指针类型决定指针+-整数跳过的大小

//取出数组的地址，为什么打印出首元素的值？
//由于取出的是数组的地址，数组的地址从首元素开始也并不奇怪
//所以打印出首元素的值也情有可原
//语法在设计时也是为了考虑方便性而这么设计的