#define _CRT_SECURE_NO_WARNINGS 1 
#include<stdio.h>
//int main()
//{
//	int a = 10;
//	int* pa = &a;
//	pa = 20;
//	//原先a里面存放的是a的地址，将20放入，那么pa的值被改为20的值，也就是0x14
//	//printf("%p %d", pa, *pa);
//	//这里*pa会报错，为什么？
//	//因为给pa重新赋值地址了，这时地址为20，那么实际上就是解引用的20这块空间
//	//但是20这块空间的地址并没有被申请，有点野指针的意思，这块空间并没有被申请，所以访问出错了
//	//可以联想为，当指针变量未被初始化时，对其进行解引用，有这块空间吗？有，属于我们程序吗？不属于！
//	//因为并没有申请，没有明确取出这块空间的地址将其赋给指针变量，所以非法访问。
//	//对于这里的20也是，我们只是把pa重新赋值了，20这块空间并不属于我们当前程序
//	//它只是内存中的值，如果需要访问，还是得创建变量，取出变量的地址，再解引用访问。
//	//保证取出的地址是属于我们当前程序的，而不是只属于内存空间中，保证取出的地址是我们当前程序内存中‘
//	//开辟的一块存放值为20的空间的地址，再对它进行解引用访问，就能达到效果。
//	//如果仅仅是创建一个变量，再将变量赋给pa，那么在赋值的过程中，还是将m也就是20赋给了pa，到时候访问的还是
//	//20的空间，换汤不换药，所以仍然会导致错误。
//	//这只是一个小探究，我们平时只需要知道，将空间里的值改变，只需要进行解引用操作
//	//拿出指针变量中的地址，找到该地址所对应的变量，把值放到变量所对应的空间里。
//	return 0;
//}
// while (a = get_val(), count_val(a), a>0)
//{
//		//业务处理
//}
//do
//{
//	a = get_val();
//	count_val(a);
//} while (a > 0);
//上面两段代码的区别：自我总结
//这两个我觉得按照他们进行的功能来说是差不多的，但是我觉得他们从循环次数上有点差别，
//第一个是一定会执行条件表达式，所以是先要执行逗号表达式的前两个表达式，
//再由最后一个表达式是否为真判断是否进入循环，条件表达式至少执行一次，循环可能不执行；
//第二个dowhile则是起码会进行一次循环，条件表达式也会执行一次；
//int main()
//{
//	int flag = 0;
//	//if(!flag)//更容易看出判断真假
//	if (flag == 0)//让人觉得是不是在判断这个值等于0？
//		printf("hehe\n");
//}
//sizeof只关注类型，不关注操作数或表达式的结果，通过计算元素类型的大小
//int main()
//{
//	int arr[10];
//	printf("%zu\n", sizeof(arr));//int [10]
//	printf("%zu\n", sizeof(arr[10]));//int
//}

//int main()
//{
//	int a = 10;
//	printf("%zu\n", sizeof(a));
//	printf("%zu\n", sizeof a);//没有括号，可以和函数调用操作符区分，sizeof是操作符
//	printf("%zu\n", sizeof(int));
//	printf("%zu\n", sizeof int);//错误
//}

int main()
{
	short s = 10;
	int a = 2;
	printf("%d\n", sizeof(s = a + 5));
	//a是int类型 + 5算出的也是int类型，把这个结果放到short类型的变量里面
	//最终结果取决于s，于是发生截断，截断高位，将4个字节砍掉两个字节放入s就可以了
	//而sizeof的计算时在编译期间进行的，他并不会在程序开始执行后计算表达式的大小
	//所以并不会对s进行计算

	//sizeof()中表达式是不会进行计算的
	printf("%d\n", s);
}